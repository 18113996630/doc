# mysql面试题

## 1.Sql优化？[重点--德邦、平安科技、简装包2017]

### SQL层面

* 根据主键查询
* 大数据表删除,用truncate table代替delete
* 合理使用索引
* 合理使用数据类型(char:定长 varchar:可变)
* 查询时,使用列名(避免select *)
* 避免复杂SQL,业务层完成(少嵌套子查询)  
* 避免在 where 条件中进行函数计算(索引失效)
* 删除重复记录
* sql 语句用大写的
* 用 IN 来替换 OR
* 连续in,使用between and
* 事务
* 禁止使用外键
* 禁止三表join(减少对表的查询)
* explain分析sql执行计划
      
### 服务层面
   配置mysql性能优化参数；
    
### 系统层面
   优化数据表结构、字段类型、字段索引、分表，分库、读写分离等等。
    
### 数据库层面
   
   优化SQL语句，合理使用字段索引
    
### 代码层面
   1) 使用缓存和NoSQL数据库方式存储，如MongoDB/Memcached/Redis来缓解高并发下数据库查询的压力
        单表50000行,或者单表容量超过2GB,才分库分表
        
   2) 报表分析系统,提前汇聚统计结果,避免每次查询数据库

[大牛是怎么思考设计SQL优化方案的？](https://www.cnblogs.com/clsn/p/8214048.html)

## 2.分页[上海触特信息科技]

### MySQL:
```sql
select *   表名    limit pageIndex,(pageIndex-1)*pageSize
```

### Oracle:
```sql
# 取前10条
SELECT * FROM 
            (SELECT ROWNUM rn,t.* FROM 
              (SELECT ename,sal FROM emp ORDER BY sal) t         --排序查询所有结果
                WHERE ROWNUM<=10)                                --限制查询的上限（pageIndex*pageSize）
              WHERE rn>5                                         --限制查询的下限(pageIndex-1)*pageSize
```

## ☆3.说出数据连接池的工作机制是什么?
  连接池的实现是以空间换时间
  优点:效率高，安全性稳定性好，节约资源
 
 工作机制:
 创建:J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。
 调用:客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。
      如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。
 释放:当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。 
 实现方式，返回的Connection是原始Connection的代理，代理Connection的close方法不是真正关连接，而是把它代理的Connection对象还回到连接池中。

## 4.外连接与内连接的区别?
内连接(自然连接):只有两个表相匹配的行才能在结果集中出现
  
外连接
  
   左外(以左边的表为主)
    
   右外(以右边的表为主)
    
   全外连接(左右两边都不受限制)

## 5.外连接中的左外连接、右外连接和全外连接有什么特点?
  左外连接：A left [outer] join B on 等值条件
  右外连接：A right [outer] join B on 等值条件
  完全外连接：A full [outer] join B on 等值条件

## 6.表级锁,行级锁和页面锁各有什么特点?
 表级锁 , 开销小，加琐快。不会出现死锁；锁粒度大，发出琐冲突的概率最高，并发度最低。
 行级锁 , 开锁大，加琐慢；会出现死琐；琐力度最小，发生琐冲突概率最低，并发度也最高。
 页面锁 , 锁力度界于表锁和行锁之间，并发度一般。

## 7.如何操作一个游标读取一个表? 写出代码?

 用过游标吗？在存储过程中用过游标吗？

## 游标的好处?[深圳市海魅蓝科技2017]
游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果

优点：

a  对从表中检索出的数据进行操作非常灵活。

b  允许应用程序对查询语句select 返回的行结果集中每一行进行相同或不同的操作。

c  提供对基于游标位置而对表中数据进行删除或更新的能力。

缺点：
    游标速度较慢

## 8.什么是存储函数? 如何声明存储函数?存储函数有什么限制?

## ☆9. 什么是存储过程? 如何创建存储过程?
 概念
 
   a.类似于C#/Java中的方法，是对代码的封装，方便用户调用
   
   b.过程可以无参，也可以接收1个或多个参数
   
   c.过程可以通过return返回1个int类型数据
   
 优点[深圳市海魅蓝科技2017]
 
   a.模块化，按功能进行封装
   
   b.重用性好，易于维护
   
   c.执行效率高，编译好之后存储在数据库中
   
   d.减少网络流量的使用
   
   e.安全性高        
   
 创建
```sql
 CREATE OR REPLACE PROCEDURE 过程名
   AS
     声明部分
   BEGIN
     逻辑处理部分
   END;
```

 调用
   BEGIN
     过程名
   END;

数据库存储过程，输入和输出参数，编程题？[恒拓开源2017年]
```
  --eg 创建过程，根据员工编号查询员工姓名（out参数）
  CREATE OR REPLACE PROCEDURE 
         proc_three(eno IN NUMBER,v_ename OUT VARCHAR2)
  AS
  BEGIN
     --eno:=7438;  --不能赋值
     dbms_output.put_line(v_ename);
     SELECT ename INTO v_ename FROM emp WHERE empno=eno;
  END;
  
  --调用
  DECLARE
     eno NUMBER;
     v_ename VARCHAR2(20);
  BEGIN
     eno := &eno;
     --v_ename:='admin';
     proc_three(eno,v_ename);
     dbms_output.put_line(v_ename);
  END;
```
  
## 10.存储过程和函数的区别[深圳市海魅蓝科技2017]

存储过程是用户定义的一系列sql语句的集合，涉及特定表或其它对象的任务，用户可以调用存储过程

函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉及特定用户表
  
## 11.事务是什么？[重点]

### 1、概念：同生共死

   1）事务是最小的逻辑单元
   
   2）该单元包含1个或者1组数据库操作
   
   3）这些数据库操作要么同时成功，要么同时失败

### 2、分类：
   
1）隐式事务
   
2）自动提交事务：针对单个数据库操作
   
   SQLServer将单个的insert/delete/update操作当作1个独立的事务，自动提交
    
3）显式事务：针对多个数据库操作
     a- 开始事务 begin transaction
     b- 提交事务 commit transaction
     c- 回滚事务 rollback transaction
注意：使用@@error累加每个操作的错误号，作为判断提交或回滚依据

### 3、特点：ACID
A- 原子性，事务是最小的、不可分割的逻辑单元
C- 一致性，事务前后的数据应保持一致
I- 隔离性，事务之间是相互独立的
D- 永久性，事务提交后对数据库的影响是永久的，一旦提交则无法回滚

### 事务的作用:
可以保证数据的一致性和完整性(避免异常和错误等导致的数据信息异常)



### Spring的事务

### 分布式事务

## 12.Oracle

①Oracle是甲骨文公司的一款关系数据库管理系统。

②Oracle主要特点：
1）完整的数据管理功能：
    1.数据的大量性
    2.数据保存的持久性
    3.数据的共享性
    4.数据的可靠性
       
2）分布式处理功能。
    
3）用ORACLE能轻松的实现数据仓库的操作。
    

③Oracle的优点：可用性强，可扩展性强，数据安全性强，稳定性强。

13.MySQL

  1.MySql是一个开放源码的小型关联式数据库管理系统。
  
  2.MySql的系统特性：
    1.为多种编程语言提供了API。
    2.支持多线程，充分利用CPU资源。
    3.提供多语言的支持。
    4.优化的SQL查询算法，提高查询的速度。
    5.提供TCP/IP、ODBC和JDBC等多种数据库连接途径
    
## 14.表和视图的区别？

## 15.Oracle的数据类型？

## 16.数据库函数？[德邦]

### 日期函数
* mysql
* oracle
* sqlServer
* hive
* mongodb

### 聚合函数
sum avg count max min
  
## 17.去除重复值？[德邦 平安]

## 18.备份还原[德邦]

## 19.MySQL使用的版本?[德邦]
经典5.7
升级8.0

[mysql8.0新特性:](https://www.cnblogs.com/xyabk/p/10882913.html)
* 账户与安全: 
    1) 用户的创建与授权分开
    2) 身份认证插件更新　
        MySQL5.7默认身份插件是mysql_native_password
        MySQL8.0默认的身份插件是caching_sha2_password
        
* 优化器索引
    1) 隐藏索引（invisible index）
        隐藏索引不会被优化器使用，但仍需要维护
        A）软删除 B) 灰度发布
    2) 降序索引（descending index）
    3) 函数索引
    
* 通用表表达式
* 窗口函数
* InnoDB 增强
1) 集成数据字段

2) 原子ddl操作
　　MySQL5.7执行drop命令 drop table t1,t2; 如果t1存在，t2不存在，会提示t2表不存在，但是t1表仍然会被删除。
　　MySQL8.0执行同样的drop命令，会提示t2表不存在，而且t1表不会被删除，保证了原子性。
　　ddl操作（针对表）的原子性前提是该表使用的存储引擎是`InnoDB`

3) 自增列持久化
  解决了之前的版本，主键重复的问题。
　MySQL5.7及其以前的版本，MySQL服务器重启，会重新扫描表的主键最大值，如果之前已经删除过id=100的数据，但是表中当前记录的最大值如果是99，那么经过扫描，下一条记录的id是100，而不是101。
　MySQL8.0则是每次在变化的时候，都会将自增计数器的最大值写入`redo log`,同时在每次检查点将其写入引擎私有的系统表。则不会出现自增主键重复的问题

4) 死锁检查控制

5) 锁定语句选项

* JSON 增强
1) JSON聚合函数
JSON_ARRAYAGG(),将多行数据组合成json数组
JSON_OBJECTAGG()，用于生成json对象

20.union和union all的区别?[中软]
合并两个结果集

21.索引为什么快？用了什么数据结构?画出数据结构？[平安]
b+tree 倒排索引

mysql中为什么不使用其他数据结构而就用B+树作为索引的数据结构

mysql索引优化实战，包括普通查询、group by、order by

索引失效:

一般来说能够达到range就可以算是优化了 idx name_deptId
口诀（两个法则加6种索引失效的情况）
全值匹配我最爱，最左前缀要遵守；
带头大哥不能死，中间兄弟不能断；
索引列上少计算，范围之后全失效；
LIKE百分写最右，覆盖索引不写*；
不等空值还有OR，索引影响要注意；
VAR引号不可丢，SQL优化有诀窍。

[explain详解:](https://www.cnblogs.com/tufujie/p/9413852.html)

![img explain详解](assets/explain.png)

* id:选择标识符,SELECT的查询序列号
* select_type:表示查询的类型,
* table:输出结果集的表
* partitions:匹配的分区
* type:表示表的连接类型
* possible_keys:表示查询时,可能使用的索引
* key:表示实际使用的索引
* key_len:索引字段的长度
* ref:列与索引的比较
* rows:扫描出的行数(估算的行数)
* filtered:按表条件过滤的行百分比
* Extra:执行情况的描述和说明
   
## 22.sqlServer和mysql的区别?[电话面试]

## 23.MySQL行锁是否会有死锁的情况？表级别锁，行级别锁？
测试环境的mysql死锁?

## 24.case when:
--简单Case函数
```sql
CASE sex
         WHEN '1' THEN '男'
         WHEN '2' THEN '女'
ELSE '其他' END
--Case搜索函数
CASE WHEN sex = '1' THEN '男'
     WHEN sex = '2' THEN '女'
ELSE '其他' END

SELECT   id, name, cj, (CASE WHEN cj < 60 THEN '不及格' WHEN cj BETWEEN 60 AND 90 THEN '良好' WHEN cj > 90 THEN '优秀' END) AS 状态 FROM stud
```

## 25.mysql执行计划详解&mysql查询优化器详解(explain)

id:SQL执行的顺序的标识,SQL从大到小的执行
1. id相同时，执行顺序由上至下
2. 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
3.id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行

select_type:查询中每个select子句的类型
A.SIMPLE(简单SELECT,不使用UNION或子查询等)
B.PRIMARY(查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY)
C.UNION(UNION中的第二个或后面的SELECT语句)
D.DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)
E.UNION RESULT(UNION的结果)
F.SUBQUERY(子查询中的第一个SELECT)
G.DEPENDENT SUBQUERY(子查询中的第一个SELECT，取决于外面的查询)
H.DERIVED(派生表的SELECT, FROM子句的子查询)
I.UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)

table:表

type:MySQL在表中找到所需行的方式，又称“访问类型”
ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行
index: Full Index Scan，index与ALL区别为index类型只遍历索引树
range:只检索给定范围的行，使用一个索引来选择行
ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件
const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system
NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。

ref:表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

Key:key列显示MySQL实际决定使用的键（索引）
如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX

rows:表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数

## 26.数据库插入字段和修改字段？[大全智能2017]
alter table 表名 add 字段名 数据类型
alter table 表名 字段名称 字段类型 [完整性约束条件]
alter table 表名 drop 字段名 

## 27.数据库题,sql语句，stu表有学生，科目，成绩3个字段[秀驿国际]
 a.每个学生的总成绩
 b.查询总成绩大于600分的学生
 
## 28.表连接查询时 大表在前小表在后？[中软国际]
   大表在前，表连接查询时后面的表必然会进行全表扫描，所以数据少的放后面，提高sql语句的执行效率 
   
## 29.[为什么mongodb的索引用了B树，而mysql用B+树？](https://blog.csdn.net/ProMonkey_chen/article/details/100579000)
[为什么MongoDB采用B树索引，而Mysql用B+树做索引](https://blog.csdn.net/ahjxhy2010/article/details/80339510)

|    MySQL    |     MongoDB      |
| :---------: | :--------------: |
| 库 Database |   库 Database    |
| 表 Table   | 集合 Collection  |
| 行 Row    |  文档 Document   |
| 列 Column  |    字段 Field    |
| joins    | 嵌入文档或者链接 |

B-树和B+树最重要的一个区别:
    B+树只有叶子节点存放数据,其余节点用来索引,时间复杂度logN
    B-树是每个索引节点都会有Data域,时间复杂度不固定,与 key 在树中的位置有关，最好为O(1)

B-树:
MongoDB 是文档型的数据库,是一种NoSql，它使用`BJSON`格式保存数据,是聚合型数据库。
    被设计用在数据模型简单,性能要求高的场合。

B树key和data域聚合在一起,减少磁盘IO,指定索引访问,不需要区间查询(不支持)

B+树:

1) 数据都存储在叶子节点,所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同,导致每一个数据的查询效率固定,时间复杂度为log N,
    B树查询时间复杂度不固定,与所查节点在树中的位置有关,最好为O(1)。

2) 区间访问: 数据全部存储在叶子节点,通过指针串在一起,容易进行区间遍历,全部遍历;通过增加**顺序访问**指针提高区间查询效率

3) 根节点存储数据,其余节点检索,适合存储外部数据(磁盘数据)

## 30.知道mysql的索引算法么？

## 31.用mysql过程中，有遇到什么问题么？
1) 分布式id生成
`snowflak`雪花算法:

#### 组成:
  第一个部分，是 1 个 bit：0，这个是无意义的。
        
  第二个部分是 41 个 bit：表示的是时间戳。
        
  第三个部分是 5 个 bit：表示的是机房 id，10001。
        
  第四个部分是 5 个 bit：表示的是机器 id，1 1001。
        
  第五个部分是 12 个 bit：表示的序号，就是某个机房某台机器上这一毫秒内同时生成的 id 的序号，0000 00000000
        
#### 时间回拨   
   nextId方法中用当前时间和上一次的时间进行判断,如果当前时间小于上一次的时间那么肯定是发生了回拨
   如果时间回拨时间较短，比如配置5ms以内，那么可以直接等待一定的时间，让机器的时间追上来
   
   如果时间的回拨时间较长,扩展位+1
      
2) UUID

3) 自增(全局库)
适合并发低,数据量大

## 32.如何保证数据库主从一致性？
主库按事务提交顺序记录binlog日志(增删改查), 从库和主库建立连接,启动IO进程,读取`binlog`日志,
将接收到的日志内容依次写入到 从库 的`relay Log`文件(mysql-relay-bin.xxxxxx)的最末端,
SQL 线程检测到 `Relay Log`新增内容,解析并查询Query

[数据库主从数据一致性的几种解决方案](https://www.cnblogs.com/KunLunSu/p/6826247.html)

1) 半同步复制
主从不一致的原因是延时引起的,所以要消除这个延时的影响，可以从主库进行CUD操作时进行规避，办法就是等主从同步完成之后，主库上的写请求再返回，就是大家常说的“半同步复制”semi-sync
请求请求主库主库从库从库CUD操作开始同步同步完成CUD操作完成
方案优点：利用数据库原生功能，比较简单
方案缺点：主库的写请求时延会增长，吞吐量会降低

2) 数据库中间件
请求请求中间件中间件主库主库从库从库CUD操作路由同步
请求请求中间件中间件主库主库从库从库R操作同步未完成同步完成
方案优点：能保证绝对一致
方案缺点：数据库中间件的成本比较高

3) 缓存记录写key法
CUD操作
 （1）将某个库上的某个key要发生写操作，记录在cache里，并设置“经验主从同步时间”的cache超时时间，例如500ms 
 （2）修改数据库
   
R操作
 （1）先到cache里查看，对应库的对应key有没有相关数据 
 （2）如果cache hit，有相关数据，说明这个key上刚发生过写操作，此时需要将请求路由到主库读最新的数据 
 （3）如果cache miss，说明这个key上近期没有发生过写操作，此时将请求路由到从库，继续读写分离
   
方案优点：相对数据库中间件，成本较低
方案缺点：方案缺点：为了保证"一致性",引入了一个cache组件，并且读写数据库时都多了一步cache操作


主从延迟
1) 拆分主库
2) 并行复制
3) 插入数据,立马查询的需求,直接查询主库,不推荐

## 33.你们数据库的高可用架构是怎么样的？
主从

## 34.关系与非关系型数据库

关系型数据库的优点：
1 支持事务处理，事务特性：原子性、一致性、隔离性、持久性。
2 数据结构清晰，便于理解，可读性高。
3 使用方便，有标准的sql语法。

关系型数据库的缺点：
1 读写性能相对较差，为保证事务的一致性，需要一定的开销。在高并发下表现的尤为突出。
2 表结构固定，不易于表后期的扩展，所以前期对表的设计要求较高。

非关系型数据库的优点：
1 读写性能高，没有保障数据的一致性。
2 表结构灵活，表结构并不是固定的，通过key-value存储数据，value又可以存储其他格式的数据。

两者的优缺点其实是相反的，一件事物不会凭空出现，都是在原有的基础上做了补充和优化，两者的侧重点各有不同。就像MySQL保障了数据的一致性，却影响了读写的性能。MongoDB放弃数据的强一致性，保障了读写的效率。在合适的场景使用合适的数据库，是需要我们考虑的。
1 对于需要高度事务特性的系统，比如和钱有关的，银行系统，金融系统。我们要考虑使用关系型数据库，确保数据的一致性和持久性。
2 对于那些数据并不是很重要，访问量又很大的系统，比如电商平台的商品信息。我们可以使用非关系型数据库来做缓存，充分提高了系统查询的性能

## 34. 引擎
|对比项|MyISAM|InnoDB|
|:---|:---:|---:|----|----|
|主外键|不支持|支持|
|事务|不支持|支持|
|行表锁|表锁,即使操作一条记录也会锁住整个表,不适合高并发的操作|行锁,操作时只锁某一行,不对其他行有影响,适合高并发的操作|
|缓存|只缓存索引,不缓存真实数据|不仅缓存索引还要缓存真实数据,对内存要求比较高,而且内存大小对性能有决定性的影响|
|表空间|小|大|
|关注点|性能|事务|
|默认安装|是|是|
|用户表默认使用|是|否|

innodb 索引 使用 B+TREE myisam 索引使用 b-tree
innodb 主键为聚簇索引，基于聚簇索引的增删改查效率非常高。