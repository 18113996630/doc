https://github.com/shishan100/Java-Interview-Advanced

https://apppukyptrl1086.pc.xiaoe-tech.com/index


### TCC事务、最终一致性技术选型

类似TCC事务的,开源框架,ByteTCC、Himly,个人技术高手自己写的,star不少,有中小型公司在生产环境使用了类似的分布式框架,知名度和普及度不高

阿里开源了分布式事务框架,fescar,技术体系上有很多地方都是有自己的东西,seata,阿里开源的分布式事务框架,类似于TCC事务,这个框架是经过阿里生产环境大量的考验的一个框架

可靠性最终一致性方案,ActiveMQ封装了一个可靠性消息服务,基于RabbitMQ封装,自己开发一个可靠性消息服务,收到一个消息之后,会尝试投递到MQ上去,投递失败,重试投递

消费成功,必填回调他的一个接口,通知他消息处理成功,如果一段时间发现消息还没有处理成功,会再次投递消息到MQ上去,在本地数据里存放一些消息,基于ActiveMQ来实现消息的异步投递和消费

RocketMQ,作为MQ中间件,提供了分布式事务支持,他把可靠性消息服务需要实现的功能逻辑都做好了



### TCC事务的核心架构

## 分布式锁

### 49、有哪个业务场景是需要用分布式锁的?为什么要使用?
下订单的的环节,支付之前,创建一个订单

创建一个订单,订单里会指定对哪些商品要购买多少件,此时就需要走一个流程,校验一下库存

查库存,确认库存充足,锁定库存，这个库存必须用分布式锁,锁掉这个商品的库存,对一个商品的购买同一时间只能有一个人操作

总结：当多个服务需要竞争一个单体资源时，可以考虑加上分布式锁。如果并发量高的话，可以考虑拆分掉那个单体资源，50个拆成5个10个资源，从而缩小锁的粒度，提高吞吐量

### 50、你们是用哪个开源框架实现的Redis分布式锁？能说说其核心原理么？
Redis分布式,很少自己撸,Redisson框架,他基于Redis实现了一系列的开箱即用的高级功能,比如说分布式锁

实现原理: 
![image](img/lock/redis-distribute-lock.png)
 
比如说,苹果这个商品的id是1
redisson.lock("product_"+1+"_stock")

key的业务语义,就是针对product_id=1的商品的库存,也就是苹果的库存,进行加锁

1). 
执行加锁命令,`redisson`会发送一个lua脚本到redis,redis部署的集群(redis-cluster、master-slaver),根据key计算slot,选择master

写入的命令,1代表客户端已经加过锁
```
product_1_stock: { 
 "xxxx": 1 
}
```

2). watchdog 看门狗
`redisson`框架后台执行一段逻辑，每隔10s去检查一下这个锁是否还被当前客户端持有，如果是的话，重新刷新一下key的生存时间为30s
生存时间：30s

3). 其他客户端尝试加锁，这个时候发现"product_1_stock"这个key已经存在了，里面显示被别的客户端加锁了，此时他就会陷入一个无限循环，阻塞住自己，不能干任何事情，必须在这里等待

4). 第一个客户端加锁成功了,此时有两种情况,第一种情况，这个客户端操作完毕之后，主动释放锁；第二种情况，如果这个客户端宕机了，那么这个客户端的redisson框架之前启动的后台watchdog线程，就没了


5). 此时最多30s,key-value就消失了,自动释放了宕机客户端之前持有的锁