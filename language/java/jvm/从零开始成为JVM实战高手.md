# 从零开始成为JVM实战高手

https://pc-shop.xiaoe-tech.com/apppuKyPtrl1086/columnist_detail?id=p_5d0ef9900e896_MyDfcJi8

# 001、开篇词：JVM优化实战，广大Java工程师心中永远的痛！

2019-06-23 12:15:22

**开篇词：**

**JVM优化实战，广大Java工程师心中永远的痛！**



平时很多朋友跑来找我问以下一些类似的问题：

1. 线上用Dubbo开发的一个系统突然卡死了，JVM FullGC太频繁，求救！

   

   

2. 生产环境部署的一个系统隔几天就莫名其妙的进程崩溃，看了眼异常信息，说是OOM内存溢出，如何解决？在线等，急！

3. 出去面试，光是说一些JVM的内存模型、垃圾回收算法，不够啊！

   面试官怎么老是盯着我问生产环境遇到的JVM问题，各种参数的优化之类的，完全没经历过



类似的问题听的多了，我发现目前国内大多数Java工程师都面临一个共同的问题。



即对JVM的了解仅停留于书本和理论知识，而对JVM生产环境中的实战优化几乎一无所知。



有的朋友是一直开发那种几十个人使用的内部系统，所以没机会接触和经历。有的朋友是突然遇到线上JVM生产事故，毫无头绪。



为什么会造成这类现状呢？



答案其实也很简单，目前国内JVM相关的学习资料主要是两类：

- 一种是一些JVM大牛作者写的书籍
- 一种是网上大量凌乱繁杂的JVM实践博客。



对于JVM大牛写的一些书籍，其实都是很好的一些资料。但是书的本意并不是提供给你实战经验。



书的作用是站在理论知识总结和梳理的角度，把一个完整的理论知识体系呈现给你。



因此，从书上学到的也主要是体系化的理论知识。



而且虽然很多书籍的作者技术功底极为深厚，但是书里的内容非常的深奥晦涩，难以理解。



导致很多人即使是这种JVM的理论知识，也仅仅是吸收了里面可能就10%的精华，其他的也没法消化理解。



更重要的，从书本中，也更不可能获得JVM生产故障的实践经验和解决方案。



然后就是网上大量凌乱繁杂的JVM相关博客，很多作者其实确实是在记录自己遇到的一些JVM的生产故障的解决过程。



但是问题在于，博客往往是作者自己记录的经历，面向的是自己，一切站在自己的角度出发。



而对于这个项目的背景、线上多大用户量、多少数据量、多大并发量、核心业务流程，在什么生产场景下发生的问题？**啥都没有！**



此外，对解决问题过程中涉及到的一些JVM底层原理，很多作者也不会说明白。



这就导致很多读者看博客，根本看不懂，搞不明白为什么会发生这个问题，搞不明白解决这个JVM生产故障背后的原理是什么！



**一句话总结**：放眼望去，目前国内并没有一个真正系统化讲解**JVM生产实战**的技术资料！



正是这个原因，导致了大量的Java工程师内心中对“**JVM实战**”这块内容有很大的痛点。



造成的直接后果就是遇到JVM生产事故不知道怎么处理和解决，出去面试被人问JVM生产实践毫无头绪！



因此我针对这些痛点，推出了**《**从零开始带你成为JVM实战高手**》**专栏。



这个专栏将作为一座桥梁，我将通过它，将我十余年线上处理JVM生产事故的经验，浓缩精华，传授给你。



考虑到目前国内大部分java程序员的JVM学习现状，这个专栏从设计时，就完全从两个角度出发：

- JVM理论知识从0起步，基于大量手绘图，保证让小白都能看懂

  

- 全程专注于JVM生产实践，主要解决JVM生产环境的参数优化，JVM GC问题和JVM OOM问题的处理



下面详细说一下上述两点：

1. 对于JVM必不可少的内存模型、类加载、垃圾回收等核心理论知识，我会采用几乎一步一图的方式进行讲解。

   另外配合上通俗易懂的大白话描述，带着大家彻底搞明白JVM底层的一些原理性知识

   JVM理论知识**讲解标准**：哪怕是对JVM完全不了解的小白同学，也一定能看得懂、学得会！

2. 然后重点，则完全放在“**实战**”二字。整个专栏一共有30多个真实的生产案例，都是我多年带团队负责的各种系统中出现和遇到的JVM生产问题，比如：

3. - 每日百万交易的支付系统的JVM生产参数优化
   - 每日上亿请求量的电商系统的GC参数优化
   - 百万级用户的在线教育平台的G1垃圾回收优化
   - 更不用说每秒10万并发的BI系统、每日百亿数据量的处理系统、视频系统、大促系统等各类系统中的JVM GC问题和JVM OOM问题的生产优化



更重要的一点，每个案例绝对**站在一个读者的角度**出发，也就是从业务背景出发。



案例中会包含这个系统的用户量、并发量、数据量以及核心业务流程，进而给出发生生产故障的真实场景



然后是一步一步如何分析、排查和定位每个问题的，包括解决问题的过程中涉及到的底层JVM原理的剖析。



我的思路，就是用大量的生产案例贯穿整个专栏，进而教给大家遇到JVM生产事故时一个常规性的定位排查、分析解决问题的思路和方法



同时通过大量真实案例的演练，让大家直接积累起丰富的生产故障排查经验



此外，在专栏中还有大量的动手实验的环节，会设计很多的实验，大家只要照着做，就可以体验到各种JVM生产问题的现场。



然后再自己一步步去进行监控、分析日志，这样可以很好的锻炼大家的动手实践能力。



而且在每周我都会留下很多作业，作业会引导你去思考你手头负责的系统。



假设你的并发量、数据量扩大100倍，你会不会遇到JVM问题？如果在你的系统中遇到问题，你该怎么来处理和解决？



通过这类作业，目的就是引导大家思考如何将学习到的各种实战技能进行落地，让自己真正掌握。



通过这样的一个JVM实战专栏的学习，我相信每个认真跟着学习下来的Java工程师，都能够拥有如下的能力：

- 对自己负责的线上系统，可以进行生产环境的JVM参数优化
- 线上遇到生产故障，自己绝对有思路去进行分析、排查和定位
- 你会清楚怎么去动手实践，明白背后的JVM的底层原理
- 此外，你通过课程积累好的几十个案例的经验，也将支撑你去对各种不同的生产故障进行解决和处理



另外专栏还会贯穿大量的**大厂JVM面试题剖析**，因此在学习完专栏过后，大家出去面试，无论是JVM的原理，还是JVM的生产实践，国内没有公司面得倒你。



最后，从这篇文章开始，咱们即将一起走过15周的学习旅程。希望15周之后，这里的每个同学都能从0开始，成为一个JVM实战高手！



**End**



# 002、一探究竟：我们写的Java代码到底是如何运行起来的？

2019-06-23 14:08:45

**一探究竟：**

**我们的Java代码到底是如何运行起来的？**

本文是我们正式开始讲解JVM的第一篇文章。

第一周我们不会讲解太多过于深奥的原理知识，那样会让很多原本对JVM不太了解的同学难以平滑的入门。

第一周的内容主要是高屋建瓴的把JVM运行机制的整体脉络梳理清楚，而很多原本对JVM就有一定了解的同学，可以耐下心来，就当做是复习梳理一下。

要研究JVM技术，先得搞明白一个问题：

- **我们平时写的Java代码，到底是怎么运行起来的？**

针对这个问题，我们来一步一步的分析。

首先假设咱们写好了一份Java代码，那这份Java代码中，是不是会包含很多的“.java”为后缀的代码文件？

比如User.java，OrderService.java，CustomerManager.java

其实咱们Java程序员平时在Eclipse、Intellij IDEA等开发工具中，就有很多类似这样的Java源代码文件。

那么大家现在思考一下，当我们写好这些“.java”后缀的代码文件之后，接下来你要部署到线上的机器上去运行，你会怎么做？

一般来说，都是把代码给打成“.jar”后缀的jar包，或者是“.war”后缀的war包，是不是？

然后呢，就是把你打包好的jar包或者是war包给放到线上机器去部署。

这个部署就有很多种途径了，但是最基本的一种方式，就是通过Tomcat这类容器来部署代码，也可以是你自己手动通过“java”命令来运行一个jar包中的代码。

咱们先用下面这张图，回忆一下这个顺序。

![01_打包.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/60992200_1561998556.png)



但是实际上这里有一个非常关键的步骤，那就是“**编译**”

也就是说，在我们写好的“.java”代码打包的过程中，一般就会把代码编译成“.class”后缀的字节码文件，比如“User.class”，“Hello.class”，”Customer.class“。

然后这个“.class”后缀的字节码文件，他才是可以被运行起来的！

所以首先，无论大家对JVM机制是否熟悉，咱们都先来回顾一下这个编译的过程，以及“.class”字节码文件的概念。

来看看下图，一起来感受一下：

![02_编译.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/85310300_1561998556.png)

接着我们可能就要思考下一个问题：

对于编译好的这些“.class”字节码，是怎么让他们运行起来的呢？

这个时候就需要使用诸如“java -jar”之类的命令来运行我们写好的代码了。

此时一旦你采用“java”命令，实际上此时就会启动一个JVM进程。

这个JVM就会来负责运行这些“.class”字节码文件，也就相当于是负责运行我们写好的系统。

所以平时我们写好的某个系统在一台机器上部署的时候，你一旦启动这个系统，其实就是启动了一个JVM，由它来负责运行这台机器上运行的这个系统。

对这个概念，大家一定要先搞清楚。

我们还是用一张图来展示一下，相信大家图文结合，会理解的更好。

![03_jvm.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/3266600_1561998557.png)



接着下一步，JVM要运行这些“.class”字节码文件中的代码，那是不是首先得把这些“.class”文件中包含的各种类给加载进来？

这些“.class”文件不就是我们写好的一个一个的类吗？对不对？

此时就会有一个“**类加载器**”的概念。

此时会采用类加载器把编译好的那些“.class”字节码文件给加载到JVM中，然后供后续代码运行来使用。

我们再看下图。

![04_类加载.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/13473300_1561998557.png)



接着，最后一步，JVM就会基于自己的**字节码执行引擎**，来执行加载到内存里的我们写好的那些类了

比如你的代码中有一个“main()”方法，那么JVM就会从这个“main()”方法开始执行里面的代码。

他需要哪个类的时候，就会使用类加载器来加载对应的类，反正对应的类就在“.class”文件中。

大家最后看看下面的图。

![05_执行代码.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24399300_1561998557.png)

好，最后我们来对本文小结一下：

无论是对JVM了解或者是不了解的同学，我们都希望通过第一周的基本原理知识讲解，降低学习后面JVM优化实战技术的门槛。

对于了解JVM的同学权当复习梳理，而且鼓励大家在底部评论发言，说说自己的理解和看法。

对于不太了解JVM的小白同学，也可以抄底门槛迅速入门，无缝衔接后续的知识学习。

所以本文从我们平时写“.java”后缀的源代码开始，一步一步梳理了以下的流程：

- 写好的代码编译成“.class”后缀的字节码文件
- JVM是个什么东西
- JVM跟我们平时运行在机器上的系统之间是什么关系
- 类加载器的概念
- 针对加载进内存的类进行代码的执行

这就是本文讲解的内容总结，希望大家对这部分内容高屋建瓴的先有一个认识。

另外，最后我给大家留一个思考题：既然“.java”文件可以编译成“.class”文件再运行，那么也肯定可以将“.class”文件反编译成“.java”文件。

但是这样的话，如果你们公司的系统代码编译好之后，都是“.class”的格式，但是被别人拿到了，反编译回来不就可以窃取你们公司的核心系统的源代码了？对这个问题，大家觉得应该怎么解决呢？

大家可以思考思考，踊跃提问和发言，明天的文章里，在末尾我会跟大家探讨一下这个问题。

**End**



# 003、面试官对于 JVM 类加载机制的猛烈炮火，你能顶住吗？

2019-06-23 14:31:28

**面试官对于JVM类加载机制的猛烈炮火，****你能顶住吗？**



**目录：**

1. 前文回顾
2. JVM在什么情况下会加载一个类？
3. 从实用角度出发，来看看验证、准备和初始化的过程
4. 核心阶段：初始化
5. 类加载器和双亲委派机制
6. 昨日思考题的解答





**1、前文回顾**

咱们今天先来回顾一下昨天讲到的JVM整体的一个运行原理。

我们首先从“.java”代码文件，编译成“.class”字节码文件

然后类加载器把“.class”字节码文件中的类给加载到JVM中

接着是JVM来执行我们写好的那些类中的代码，整体是这么个顺序。

再看看下图，感受一下这个过程：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/67189100_1562062006.cn/txdocpic/0/85881164faa1fa93a71120127057d4c3/0)

那么今天，我们就来仔细看看上图中的“**类加载**”这个过程，看看JVM的类加载机制到底是怎么样的？

搞清楚这个过程了，那么以后在面试时，对面试官常问的JVM类加载机制，就能把一些核心概念说清楚了。



**2、JVM在什么情况下会加载一个类？**

其实类加载过程非常的琐碎复杂，但是对于我们平时从工作中实用的角度来说，主要是把握他的核心工作原理就可以。

一个类从加载到使用，一般会经历下面的这个过程：

**加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载**

所以首先要搞明白的第一个问题，就是JVM在执行我们写好的代码的过程中，一般在什么情况下会去加载一个类呢？

也就是说，啥时候会从“.class”字节码文件中加载这个类到JVM内存里来。

其实答案非常简单，就是在**你的代码中用到这个类的时候**。

举个简单的例子，比如下面你有一个类（Kafka.class），里面有一个“main()”方法作为主入口。

那么一旦你的JVM进程启动之后，它一定会先把你的这个类（Kafka.cass）加载到内存里，然后从“main()”方法的入口代码开始执行。

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/81370700_1562062006.png)



我们还是坚持一步一图，大家先看看下图，感受一下：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/99941000_1562062006.cn/txdocpic/0/20b99ce2902c58d0a246861f046cc402/0)

接着假设上面的代码中，出现了如下的这么一行代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/16673900_1562062007.png)



这时可能大家就想了，你的代码中明显需要使用“ReplicaManager”这个类去实例化一个对象，此时必须得把“ReplicaManager.class”字节码文件中的这个类加载到内存里来啊！是不是？

所以这个时候就会触发JVM通过类加载器，从“ReplicaManager.class”字节码文件中加载对应的类到内存里来使用，这样代码才能跑起来。

我们来看下面的图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/34835300_1562062007.cn/txdocpic/0/8a2acdae659f69979687cafb5470e80a/0)

上面就是给大家举的一个例子，相信非常的通俗易懂。

简单概括一下：首先你的代码中包含“main()”方法的主类一定会在JVM进程启动之后被加载到内存，开始执行你的“main()”方法中的代码

接着遇到你使用了别的类，比如“ReplicaManager”，此时就会从对应的“.class”字节码文件加载对应的类到内存里来。



**3、从实用角度出发，来看看验证、准备和初始化的过程**

其实上面的类加载时机的问题，对于很多有经验的同学来说不是什么问题。

但是对于很多初学者来说，是一个非常重要的需要捋清的概念。

接下来就来简单带着大家，从实用的角度出发，过一下另外三个概念：

**验证、准备、初始化**

其实对于这三个概念，没太大的必要去深究里面的细节，这里的细节很多很繁琐，对于大部分同学而言，只要脑子里有下面的几个概念就可以了：

**（1）验证阶段**

简单来说，这一步就是根据Java虚拟机规范，来校验你加载进来的“.class”文件中的内容，是否符合指定的规范。

这个相信很好理解，假如说，你的“.class”文件被人篡改了，里面的字节码压根儿不符合规范，那么JVM是没法去执行这个字节码的！

所以把“.class”加载到内存里之后，必须先验证一下，校验他必须完全符合JVM规范，后续才能交给JVM来运行。

下面用一张图，展示了这个过程：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/47365600_1562062007.cn/txdocpic/0/9b5b706b0486cce3c20e53cc2d13cd07/0)

**（2）准备阶段**

这个阶段其实也很好理解，咱们都知道，我们写好的那些类，其实都有一些类变量

比如下面的这个“ReplicaManager”类：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/71602900_1562062007.png)

假设你有这么一个“ReplicaManager”类，他的“ReplicaManager.class”文件内容刚刚被加载到内存之后，会进行验证，确认这个字节码文件的内容是规范的

接着就会进行准备工作。

这个准备工作，其实就是给这个“ReplicaManager”类分配一定的内存空间

然后给他里面的类变量（也就是static修饰的变量）分配内存空间，来一个默认的初始值

比如上面的示例里，就会给“flushInterval”这个类变量分配内容空间，给一个“0”这个初始值。

整个过程，如下图所示：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/83060200_1562062007.cn/txdocpic/0/c9f43e3b1451aa91cfbfb8a7b6abad30/0)



**（3）解析阶段**

这个阶段干的事儿，实际上是把**符号引用替换为直接引用**的过程，其实这个部分的内容很复杂，涉及到JVM的底层

但是注意，同学们，就我本意而言，希望第一周的文章，绝对是浅显易懂的，循序渐进，要保证每个同学都能绝对看懂。

所以针对这个阶段，现在不打算做过深的解读，因为从实用角度而言，对很多同学在工作中实践JVM技术其实也用不到，所以这里大家就暂时知道有这么一个阶段就可以了。

同样，我还是给大家画图展示一下：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/96343600_1562062007.cn/txdocpic/0/34ebc43cda680141456638ca4963e770/0)

**（4）三个阶段的小结**

其实这三个阶段里，最核心的大家务必关注的，就是**“准备阶段”**

因为这个阶段是给加载进来的类分配好了内存空间，类变量也分配好了内存空间，并且给了默认的初始值，这个概念，大家心里一定要有。



**4、核心阶段：初始化**

之前说过，在准备阶段时，就会把我们的“ReplicaManager”类给分配好内存空间

另外他的一个类变量“flushInterval”也会给一个默认的初始值“0”，那么接下来，在初始化阶段，就会正式执行我们的类初始化的代码了。

那么什么是类初始化的代码呢？我们来看看下面这段代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/8399800_1562062008.png)

大家可以看到，对于“flushInterval”这个类变量，我们是打算通过Configuration.getInt("replica.flush.interval")这段代码来获取一个值，并且赋值给他的

但是在准备阶段会执行这个赋值逻辑吗？

**NO！**在准备阶段，仅仅是给“flushInterval”类变量开辟一个内存空间，然后给个初始值“0”罢了。

那么这段赋值的代码什么时候执行呢？答案是在**“初始化”**阶段来执行。

在这个阶段，就会执行类的初始化代码，比如上面的  Configuration.getInt("replica.flush.interval")  代码就会在这里执行，完成一个配置项的读取，然后赋值给这个类变量“flushInterval”。

另外比如下图的static静态代码块，也会在这个阶段来执行。

类似下面的代码语义，可以理解为类初始化的时候，调用“loadReplicaFromDish()”方法从磁盘中加载数据副本，并且放在静态变量“replicas”中：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/24615100_1562062008.png)

那么搞明白了类的初始化是什么，就得来看看类的初始化的规则了。

**什么时候会初始化一个类？**

一般来说有以下一些时机：比如“new ReplicaManager()”来实例化类的对象了，此时就会触发类的加载到初始化的全过程，把这个类准备好，然后再实例化一个对象出来；

或者是包含“main()”方法的主类，必须是立马初始化的。

此外，这里还有一个非常重要的规则，就是如果初始化一个类的时候，发现他的父类还没初始化，那么必须先初始化他的父类

比如下面的代码：

![image.png](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/41037200_1562062008.png)

如果你要“new ReplicaManager()”初始化这个类的实例，那么会加载这个类，然后初始化这个类

但是初始化这个类之前，发现AbstractDataManager作为父类还没加载和初始化，那么必须先加载这个父类，并且初始化这个父类。

这个规则，大家必须得牢记，再来一张图，借助图片来进行理解：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/53805800_1562062008.cn/txdocpic/0/605fa929375991cb7645c28f8f815b0f/0)



**5、类加载器和双亲委派机制**

现在相信大家都搞明白了整个类加载从触发时机到初始化的过程了，接着给大家说一下类加载器的概念

因为实现上述过程，那必须是依靠类加载器来实现的

那么Java里有哪些类加载器呢？简单来说有下面几种：

**（1）启动类加载器**

**Bootstrap ClassLoader**，他主要是负责加载我们在机器上安装的Java目录下的核心类的

相信大家都知道，如果你要在一个机器上运行自己写好的Java系统，无论是windows笔记本，还是linux服务器，是不是都得装一下JDK？

那么在你的Java安装目录下，就有一个“**lib**”目录，大家可以自己去找找看，这里就有Java最核心的一些类库，支撑你的Java系统的运行。

所以一旦你的JVM启动，那么首先就会依托启动类加载器，去加载你的Java安装目录下的“lib”目录中的核心类库。

**（2）扩展类加载器**

**Extension ClassLoader**，这个类加载器其实也是类似的，就是你的Java安装目录下，有一个“lib\ext”目录

这里面有一些类，就是需要使用这个类加载器来加载的，支撑你的系统的运行。

那么你的JVM一旦启动，是不是也得从Java安装目录下，加载这个“lib\ext”目录中的类？

**（3）应用程序类加载器**

**Application ClassLoader**，这类加载器就负责去加载“ClassPath”环境变量所指定的路径中的类

其实你大致就理解为去加载你写好的Java代码吧，这个类加载器就负责加载你写好的那些类到内存里。

**（4）自定义类加载器**

除了上面那几种之外，还可以自定义类加载器，去根据你自己的需求加载你的类。

**（5）双亲委派机制**

JVM的类加载器是有亲子层级结构的，就是说启动类加载器是最上层的，扩展类加载器在第二层，第三层是应用程序类加载器，最后一层是自定义类加载器。

大家看下图：

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/65579400_1562062008.cn/txdocpic/0/932fe13b12b449c8a97fc42e6029b613/0)

然后，基于这个亲子层级结构，就有一个**双亲委派的机制**

什么意思呢？

就是假设你的应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载

但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器。

听完了上面一大堆绕口令，是不是很迷茫？别着急，咱们用一个例子来说明一下。

比如你的JVM现在需要加载“ReplicaManager”类，此时应用程序类加载器会问问自己的爸爸，也就是扩展类加载器，你能加载到这个类吗？

然后扩展类加载器直接问自己的爸爸，启动类加载器，你能加载到这个类吗？

启动类加载器心想，我在Java安装目录下，没找到这个类啊，**自己找去**！

然后，就下推加载权利给扩展类加载器这个儿子，结果扩展类加载器找了半天，也没找到自己负责的目录中有这个类。

这时他很生气，说：明明就是你应用程序加载器自己负责的，你自己找去。

然后应用程序类加载器在自己负责的范围内，比如就是你写好的那个系统打包成的jar包吧，一下子发现，就在这里！然后就自己把这个类加载到内存里去了。

这就是所谓的**双亲委派模型：**先找父亲去加载，不行的话再由儿子来加载。

这样的话，可以避免多层级的加载器结构重复加载某些类。

最后，给大家来一张图图，感受一下类加载器的双亲委派模型。

![img](http://wechatapppro-1252524126.file.myqcloud.com/apppuKyPtrl1086/image/ueditor/79558100_1562062008.cn/txdocpic/0/a4c3566192eda95243843644e13dee6d/0)



**6、昨日思考题的解答**

好！今天的文章看完了，相信大家就能大致推测出昨日的思考题的答案了。

我昨天的问题是：如何对“.class”文件处理保证不被人拿到以后反编译获取公司源代码？

其实认真看完今天的文章，就很简单了。

首先你编译时，就可以采用一些小工具对字节码加密，或者做混淆等处理

现在有很多第三方公司，都是专门做商业级的字节码文件加密的，所以可以付费购买他们的产品。

然后在类加载的时候，对加密的类，考虑采用自定义的类加载器来解密文件即可，这样就可以保证你的源代码不被人窃取。

**7、今日思考题**

今天再给大家留一个思考题，相信每个做Java的同学，都知道现在一般用Java开发的Web系统，除非是基于Java写中间件，一般都是采用Tomcat之类的Web容器来部署的。

那么大家想想，Tomcat本身就是用Java写的，他自己就是一个JVM。

我们写好的那些系统程序，说白了，就是一堆编译好的.class文件放入一个war包，然后在Tomcat中来运行的。

那么，Tomcat的类加载机制应该怎么设计，才能把我们动态部署进去的war包中的类，加载到Tomcat自身运行的JVM中，然后去执行那些我们写好的代码呢？

大家先思考，明天文末会给大家进行梳理并给出答案。

**End**