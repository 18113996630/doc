# 缓存

## doc

[后端缓存的23个关键关注点](https://mp.weixin.qq.com/s/yGh9hI-bz_yyrIdBFwwyqA)

[阿里一面：关于【缓存穿透、缓存击穿、缓存雪崩、热点数据失效】问题的解决方案](https://mp.weixin.qq.com/s/7gbJCeBKklTlAxU_vsrIxg)

[如何保证缓存与数据库的双写一致性？](https://blog.csdn.net/chang384915878/article/details/86756463)

### 热点key

[如果20万用户同时访问一个热点缓存，如何优化你的缓存架构？](https://mp.weixin.qq.com/s/RqBla4rg8ut3zEBKhyBo1w)

[缓存穿透，缓存击穿，缓存雪崩解决方案分析](https://mp.weixin.qq.com/s/UNZ7rQHYwvinMW5jkRI6gw)

[一个牛逼的多级缓存实现方案](https://mp.weixin.qq.com/s/SIv-vtMpSQqod3ou0CuGkQ)

热点key发现

### 缓存预热

### 缓存更新

### 缓存穿透

缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

解决方案

1.缓存空值
   之所以会发生穿透，就是因为缓存中没有存储这些空数据的key（不管是数据不存在，还是系统故障）。从而导致每次查询都到数据库去了。
    
   那么我们就可以为这些key对应的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null 。
    
   这样，就不用在到数据库中去走一圈了，但是别忘了设置过期时间(过期时间会很短，最长不超过五分钟)
       
2.BloomFilter(最常见 布隆过滤器)
    
    将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
    
    BloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中。
    
    这种方式在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。还有在爬虫场景判断url 是否已经被爬取过。
    
    这种方案可以加在缓存空值方案中，在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -> 查 DB

如何选择

针对于一些恶意攻击，攻击带过来的大量key 是不存在的，那么我们采用缓存空值方案就会缓存大量不存在key的数据。

此时我们采用缓存空值方案就不合适了，我们完全可以先对使用BloomFilter方案进行过滤掉这些key。

针对这种key异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。

而对于空数据的key有限的，重复率比较高的，我们则可以采用缓存空值方式进行缓存




### 缓存击穿

对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。

缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

解决方案

1、使用互斥锁(mutex key)

2、"提前"使用互斥锁(mutex key)

3、"永远不过期"

4、资源保护

### 缓存雪崩

缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。

解决方案

缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。